<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>xml→ドレミ付き楽譜生成 by gannbaru306</title>
  <style>
    body{font-family:sans-serif;padding:1.5em;background:#f4f7fb;text-align:center}
    #scoreContainer{background:#fff;border:1px solid #ccc;min-height:220px;padding:1em;margin:1em auto;max-width:900px}
    #status{white-space:pre-line;text-align:left;max-width:900px;margin:0 auto;background:#fff;border:1px solid #ddd;padding:0.6em}
    input,button{padding:0.6em 1em;margin:0.4em}
  </style>
</head>
<body>
  <h1>xml→ドレミ付き楽譜v2.0</h1>

  <div>
    <input type="file" id="fileInput" accept=".xml,.musicxml,.mxl" />
    <button id="loadBtn">読み込み開始</button>
    <button id="pdfBtn">PDFプレビュー / 保存</button>
  </div>

  <p id="status">ライブラリ読み込み待機中...</p>
  <div id="scoreContainer"></div>

  <!-- ライブラリは defer なしで確実に先にロード -->
  <script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.7.6/build/opensheetmusicdisplay.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
  const statusEl = document.getElementById("status");
  function logStatus(s){ statusEl.textContent = new Date().toLocaleTimeString() + " — " + s; }

  logStatus("OSMDライブラリのロード確認中...");

  // OSMDを待つループ
  const checkLib = setInterval(() => {
    if (window.opensheetmusicdisplay?.OpenSheetMusicDisplay) {
      clearInterval(checkLib);
      logStatus("OSMDロード完了！初期化開始...");
      initApp();
    } else {
      logStatus("OSMDを読み込み中...（ネット通信待機）");
    }
  }, 700);

  async function initApp(){
    const container = document.getElementById("scoreContainer");
    window.jsPDF = window.jspdf?.jsPDF || window.jsPDF;

const osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(container, {
  backend: "svg",
  drawingParameters: "default",
  drawTitle: true,
  drawPartNames: true,
  drawFromMeasureNumber: 1,
  drawUpToMeasureNumber: Number.MAX_SAFE_INTEGER,
  zoom: 1.0,
  autoResize: true,
  pageBackgroundColor: "#ffffff",
  renderSingleHorizontalStaffline: false,
});

osmd.setPageFormat("A4", "portrait");
osmd.EngravingRules.PageFormat = 0;
osmd.EngravingRules.RenderSingleHorizontalStaffline = false;
osmd.EngravingRules.PageMode = 1;
    logStatus("OSMD初期化完了。ファイルを選択して「読み込み開始」を押してください。");

    function toDoremi(step, alter, octave){
      const base = {C:"ド", D:"レ", E:"ミ", F:"ファ", G:"ソ", A:"ラ", B:"シ"};
      let name = base[step] || step;
      if (alter === 1) name += "#";
      if (alter === -1) name += "♭";
      const offset = octave - 4 + 2;
      const supers = ["⁻¹","⁰","¹","²","³","⁴","⁵","⁶","⁷","⁸"][offset] || `(${octave})`;
      return name + supers;
    }

    function processXML(xmlText){
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlText, "text/xml");
      if (xmlDoc.getElementsByTagName("parsererror").length)
        throw new Error("XML parse error");

      const notes = xmlDoc.getElementsByTagName("note");
      let chordGroup = [];

      function flushChordGroup(){
        if (chordGroup.length <= 1) { chordGroup = []; return; }
        chordGroup.forEach((noteNode, idx) => {
          const pitch = noteNode.getElementsByTagName("pitch")[0];
          if (!pitch) return;
          const step = pitch.getElementsByTagName("step")[0]?.textContent;
          const alter = parseInt(pitch.getElementsByTagName("alter")[0]?.textContent || 0);
          const octave = parseInt(pitch.getElementsByTagName("octave")[0]?.textContent || 4);
          const lyricText = toDoremi(step, alter, octave);
          const lyric = xmlDoc.createElement("lyric");
          lyric.setAttribute("number", idx + 1);
          const text = xmlDoc.createElement("text");
          text.textContent = lyricText;
          lyric.appendChild(text);
          noteNode.appendChild(lyric);
        });
        chordGroup = [];
      }

      for (let i=0; i<notes.length; i++){
        const n = notes[i];
        const isChord = n.getElementsByTagName("chord").length > 0;
        if (!isChord){ flushChordGroup(); chordGroup = [n]; }
        else { chordGroup.push(n); }
      }
      flushChordGroup();
      return new XMLSerializer().serializeToString(xmlDoc);
    }

    document.getElementById("loadBtn").addEventListener("click", () => {
      const file = document.getElementById("fileInput").files[0];
      if (!file){ logStatus("ファイルを選択してください。"); return; }

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          if (file.name.endsWith(".mxl")) await osmd.load(e.target.result);
          else await osmd.load(processXML(e.target.result));
          await osmd.render();
          logStatus("レンダリング完了！");
        } catch(err){
          logStatus("読み込みエラー: " + err);
        }
      };
      if (file.name.endsWith(".mxl")) reader.readAsArrayBuffer(file);
      else reader.readAsText(file, "UTF-8");
    });

   // ↓ これを既存の pdfBtn.addEventListener(...) の中身と丸ごと置き換えてください
document.getElementById("pdfBtn").addEventListener("click", async () => {
  try {
    const svg = container.querySelector("svg");
    if (!svg) {
      return logStatus("まだ楽譜がありません。");
    }

    logStatus("PDF生成中...（比率を維持して出力します）");

    // --- SVG のサイズを安全に取得する --- //
    // 優先順: viewBox のサイズ -> svg width/height 属性 -> getBBox() -> getBoundingClientRect()
    let svgWidth = 0, svgHeight = 0;
    try {
      if (svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width) {
        svgWidth = svg.viewBox.baseVal.width;
        svgHeight = svg.viewBox.baseVal.height;
      } else if (svg.getAttribute("width") && svg.getAttribute("height")) {
        svgWidth = parseFloat(svg.getAttribute("width"));
        svgHeight = parseFloat(svg.getAttribute("height"));
      } else {
        // getBBox は要素内の図形の実寸を返す（フォールバック）
        const box = svg.getBBox ? svg.getBBox() : null;
        if (box && box.width && box.height) {
          svgWidth = box.width;
          svgHeight = box.height;
        } else {
          const rect = svg.getBoundingClientRect();
          svgWidth = rect.width;
          svgHeight = rect.height;
        }
      }
    } catch (e) {
      // 何か取れなければ、表示寸法から推定
      const rect = svg.getBoundingClientRect();
      svgWidth = rect.width;
      svgHeight = rect.height;
    }

    if (!svgWidth || !svgHeight) {
      // 最低限のフォールバック値
      svgWidth = 800;
      svgHeight = 1000;
    }

    // --- jsPDF の初期化（A4 縦 / pt 単位） --- //
    const pdf = new jsPDF({ orientation: "portrait", unit: "pt", format: "a4" });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // --- 比率を維持してスケール計算 --- //
    const scale = Math.min(pageWidth / svgWidth, pageHeight / svgHeight);
    const renderWidth = svgWidth * scale;
    const renderHeight = svgHeight * scale;

    // 中央配置オフセット（pt）
    const xOffset = (pageWidth - renderWidth) / 2;
    const yOffset = (pageHeight - renderHeight) / 2;

    // --- SVG を画像に変換して追加 --- //
    const svgData = new XMLSerializer().serializeToString(svg);

    // 背景白を入れたい場合（透明だと見づらい時）
    let svgString = svgData;
    if (!/fill="#ffffff"/i.test(svgString)) {
      // 小さな挿入 — <svg ...> の直後に白矩形を追加
      svgString = svgString.replace(/<svg([^>]*)>/, `<svg$1><rect width="100%" height="100%" fill="#ffffff"/>`);
    }

    const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const img = new Image();

    // CORS 対策（iPadでの読み込み安定化）
    img.crossOrigin = "anonymous";

    img.onload = function () {
      try {
        // ここでは canvas を使わずに直接 addImage(img...) を使う（多くの環境で動作する）
        // ただし、一部ブラウザでは画像オブジェクトを直接 addImage に渡せないため canvas 経由の手段も用意
        const useDirect = false; // false の場合は下の canvas フローへ
        if (useDirect && pdf.addImage.length) {
          pdf.addImage(img, "PNG", xOffset, yOffset, renderWidth, renderHeight);
          pdf.save("score.pdf");
          URL.revokeObjectURL(url);
          logStatus("PDF保存完了");
          return;
        }

        // Canvas を使う安全なフロー（レンダリング比を維持）
        const canvas = document.createElement("canvas");
        // canvasのピクセルは pt 変換を考慮して余裕を持たせる（高解像度）
        const DPR = 2; // device pixel ratio 的に 2 倍で描く（必要なら 3 に）
        canvas.width = Math.ceil(renderWidth * DPR);
        canvas.height = Math.ceil(renderHeight * DPR);
        const ctx = canvas.getContext("2d");
        // スケールして描画（画像をキャンバスに引き伸ばすが、レンダリング幅/高さは比率に合わせている）
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.drawImage(img, 0, 0, renderWidth, renderHeight);

        const imgData = canvas.toDataURL("image/png", 1.0);
        pdf.addImage(imgData, "PNG", xOffset, yOffset, renderWidth, renderHeight);
        pdf.save("score.pdf");
        URL.revokeObjectURL(url);
        logStatus("PDF保存完了");
      } catch (err) {
        console.error(err);
        logStatus("PDF生成で内部エラーが起きました");
        URL.revokeObjectURL(url);
      }
    };

    img.onerror = function (err) {
      console.error(err);
      URL.revokeObjectURL(url);
      logStatus("SVGを画像に変換できませんでした（imgロード失敗）");
    };

    img.src = url;

  } catch (e) {
    console.error(e);
    logStatus("PDF生成エラー: " + e);
  }
});

  </script>
</body>
</html>
