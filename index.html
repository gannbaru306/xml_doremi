<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ドレミ付き楽譜生成 by gannbaru306</title>
  <style>
    body{font-family:sans-serif;padding:1.5em;background:#f4f7fb;text-align:center}
    #scoreContainer{background:#fff;border:1px solid #ccc;min-height:220px;padding:1em;margin:1em auto;max-width:900px}
    #status{white-space:pre-line;text-align:left;max-width:900px;margin:0 auto;background:#fff;border:1px solid #ddd;padding:0.6em}
    input,button{padding:0.6em 1em;margin:0.4em}
  </style>
</head>
<body>
  <h1>xml→ドレミ付き楽譜</h1>

  <div>
    <input type="file" id="fileInput" accept=".xml,.musicxml" />
    <button id="loadBtn">読み込み開始</button>
    <button id="pdfBtn">PDFプレビュー / 保存</button>
  </div>

  <p id="status">待機中</p>

  <div id="scoreContainer"></div>

  <!-- ライブラリ -->
 <script src="https://unpkg.com/opensheetmusicdisplay/build/opensheetmusicdisplay.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const statusEl = document.getElementById("status");
  function logStatus(s){ statusEl.textContent = (new Date()).toLocaleTimeString() + " — " + s; }

  // Safari対応でjsPDFを確保
  try {
    window.jsPDF = window.jspdf && window.jspdf.jsPDF ? window.jspdf.jsPDF : window.jsPDF;
  } catch(e){
    // nothing
  }

  logStatus("ライブラリ読み込みチェック中...");

  // ライブラリ存在チェック（見える化）
  if(!window.OpenSheetMusicDisplay){
  logStatus("エラー: OpenSheetMusicDisplay が読み込まれていません。ネット接続を確認してください。");
  return;
}
  if(!window.html2canvas){
    logStatus("エラー: html2canvas が読み込まれていません。");
    return;
  }
  if(!window.jspdf && !window.jsPDF){
    logStatus("警告: jsPDF が見つかりません（PDF機能は制限されます）。");
  } else {
    logStatus("ライブラリ読み込みOK。OSMD初期化します...");
  }

  // OSMD 初期化（DOM確実参照）
  let osmd;
  try {
    const container = document.getElementById("scoreContainer");
    osmd = new OpenSheetMusicDisplay(container);
    logStatus("OSMD初期化完了。ファイルを選択して「読み込み開始」を押してください。");
  } catch(err){
    logStatus("エラー: OSMD初期化に失敗しました。\n" + err.toString());
    return;
  }

  // 変換ヘルパー（ドレミ付与）
  function toDoremi(step, alter, octave){
    const base = {C:"ド", D:"レ", E:"ミ", F:"ファ", G:"ソ", A:"ラ", B:"シ"};
    let name = base[step] || step;
    if (alter === 1) name += "#";
    if (alter === -1) name += "♭";
    const offset = octave - 4 + 2;
    const supers = ["⁻¹","⁰","¹","²","³","⁴","⁵","⁶","⁷","⁸"][offset] || `(${octave})`;
    return name + supers;
  }

  function processXML(xmlText){
    try{
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlText,"text/xml");
      // check parseerror
      const pe = xmlDoc.getElementsByTagName("parsererror");
      if(pe.length) throw new Error("XML parse error");
      const notes = xmlDoc.getElementsByTagName("note");
      for(let i=0;i<notes.length;i++){
        const n = notes[i];
        const pitch = n.getElementsByTagName("pitch")[0];
        if(pitch){
          const step = pitch.getElementsByTagName("step")[0]?.textContent;
          const alter = parseInt(pitch.getElementsByTagName("alter")[0]?.textContent || 0);
          const octave = parseInt(pitch.getElementsByTagName("octave")[0]?.textContent || 4);
          const lyricText = toDoremi(step,alter,octave);
          const lyric = xmlDoc.createElement("lyric");
          const text = xmlDoc.createElement("text");
          text.textContent = lyricText;
          lyric.appendChild(text);
          n.appendChild(lyric);
        }
      }
      return new XMLSerializer().serializeToString(xmlDoc);
    } catch(e){
      throw new Error("processXML失敗: " + e.message);
    }
  }

  // ファイル処理
  const fileInput = document.getElementById("fileInput");
  const loadBtn = document.getElementById("loadBtn");
  loadBtn.addEventListener("click", () => {
    const file = fileInput.files[0];
    if(!file){
      logStatus("ファイルが選択されていません。左のボタンで .xml/.musicxml を選んでください。");
      return;
    }
    logStatus("ファイル選択: " + file.name + " — 読み込みを開始します...");
    const reader = new FileReader();

    reader.onloadstart = () => logStatus("FileReader: 読み込み開始...");
    reader.onerror = () => logStatus("FileReader: 読み込みエラーが発生しました。ファイルを確認してください。");
    reader.onabort = () => logStatus("FileReader: 読み込みが中断されました。");
    reader.onload = async (e) => {
      try {
        logStatus("FileReader: 読み込み成功。XML処理中...");
        const processedXml = processXML(e.target.result);
        logStatus("XML加工完了。OSMDにロード中...");
        await osmd.load(processedXml);
        logStatus("OSMD.load 完了。レンダリング中...");
        await osmd.render();
        logStatus("レンダリング完了：楽譜が表示されました。 (" + file.name + ")");
      } catch(err){
        logStatus("読み込み/描画エラー:\n" + err.toString());
      }
    };

    // iPadでの文字コード問題回避
    reader.readAsText(file, "UTF-8");
  });

  const pdfBtn = document.getElementById("pdfBtn");
 pdfBtn.addEventListener("click", async () => {
  try {
  pdfBtn.addEventListener("click", async () => {
  try {
    logStatus("PDF処理：SVG→PNG変換中...");

    const svg = document.querySelector("#scoreContainer svg");
    if (!svg) {
      logStatus("エラー: 楽譜SVGが見つかりません。まず楽譜を読み込んでください。");
      return;
    }

    // SVG を PNG の dataURL に変換するヘルパー
    async function svgToPngDataUrl(svgElement, width, height) {
      // シリアライズ
      const serializer = new XMLSerializer();
      let svgString = serializer.serializeToString(svgElement);

      // SVG に xmlns が無ければ付与（安全策）
      if (!svgString.match(/^<svg[^>]+xmlns="http:\/\/www\.w3\.org\/2000\/svg"/)) {
        svgString = svgString.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
      }

      // 背景が透明だとPDF側で白くなる／見えなくなることがあるため白背景を挿入
      // <svg ...> の直後に矩形を入れる（既に矩形があるなら二重になるが問題は小さい）
      svgString = svgString.replace(/<svg([^>]*)>/, `<svg$1><rect width="100%" height="100%" fill="#ffffff"/>`);

      const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      // Image を作って canvas に描画（createImageBitmap があればそちらを使う）
      try {
        const imgBitmap = await (typeof createImageBitmap === "function"
          ? createImageBitmap(blob)
          : (async () => {
              return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                  // draw to offscreen canvas via Image
                  const c = document.createElement("canvas");
                  c.width = width;
                  c.height = height;
                  const ctx = c.getContext("2d");
                  ctx.drawImage(img, 0, 0, width, height);
                  c.toBlob(b => resolve(createImageBitmap(b)), "image/png");
                };
                img.onerror = (e) => reject(e);
                img.src = url;
              });
            })()
        );

        // imgBitmap を canvas に描画して dataURL 取得
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(imgBitmap, 0, 0, width, height);

        URL.revokeObjectURL(url);
        return canvas.toDataURL("image/png");
      } catch (err) {
        // createImageBitmap が使えない・失敗した場合のフォールバック
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            const c = document.createElement("canvas");
            c.width = width;
            c.height = height;
            const ctx = c.getContext("2d");
            ctx.drawImage(img, 0, 0, width, height);
            URL.revokeObjectURL(url);
            resolve(c.toDataURL("image/png"));
          };
          img.onerror = (e) => {
            URL.revokeObjectURL(url);
            reject(e);
          };
          img.src = url;
        });
      }
    }

    // PDF のページサイズに合わせた幅を計算（pt単位で jsPDF の幅を使う）
    const jsPDFConstructor = window.jspdf?.jsPDF || window.jsPDF;
    if (!jsPDFConstructor) {
      logStatus("エラー: jsPDF が利用できません。");
      return;
    }
    const pdf = new jsPDFConstructor("p", "pt", "a4");
    const pdfWidthPt = pdf.internal.pageSize.getWidth(); // pt
    // SVG の実際のサイズ（取得できれば使う）
    const svgBBox = svg.getBBox ? svg.getBBox() : null;
    const svgWidth = svgBBox && svgBBox.width ? svgBBox.width : (svg.clientWidth || 800);
    const svgHeight = svgBBox && svgBBox.height ? svgBBox.height : (svg.clientHeight || 1000);

    // PDFに合わせたピクセル幅・高さ（目安）
    // jsPDF は pt 単位 (1pt ≒ 1.333px at 96dpi) — ここでは幅をpdf幅に合わせて高さを比率で計算
    const targetWidthPx = Math.floor(pdfWidthPt * (96 / 72)); // convert pt->px (approx)
    const targetHeightPx = Math.max( Math.floor((svgHeight * targetWidthPx) / svgWidth), 100 );

    logStatus("SVG→PNG変換: " + targetWidthPx + "x" + targetHeightPx);
    const dataUrl = await svgToPngDataUrl(svg, targetWidthPx, targetHeightPx);

    logStatus("PNG変換完了。PDFに追加中...");
    const imgProps = pdf.getImageProperties(dataUrl);
    const pdfW = pdf.internal.pageSize.getWidth();
    const pdfH = (imgProps.height * pdfW) / imgProps.width;

    pdf.addImage(dataUrl, "PNG", 0, 0, pdfW, pdfH);
    pdf.save("score_doremi.pdf");
    logStatus("PDF保存完了！");
  } catch (e) {
    logStatus("PDF生成でエラー: " + e.toString());
  }
});
}
});

</script>
</body>
</html>
